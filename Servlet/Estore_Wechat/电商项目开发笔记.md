## Estore+Wechat 实现社交电商

### 前言

>- 项目模块
>
>  - [estore](https://github.com/gpengDemo/Estore)
>  - [wechat](https://github.com/misterchaos/wechat)
>  - networkGame
>
>- 技术架构
>  - **estore模块**： 
>
>    1. 开发工具 `IntelliJ IDEA`
>    2. 数据库 `Server version: 5.7.25 MySQL Community Server (GPL)`
>    3. 服务器 `apache-tomcat-9.0.19`
>    4. 数据库连接 `mysql-connector-java-5.1.47.jar`
>    5. 后端技术：Servlet + Filter + jsp
>    6. 数据库链接：dbutils
>
>  - **wechat模块：**
>
>    wechat是一个在线聊天系统，提供实时聊天，账户管理，好友管理，聊天记录管理，聊天群组，朋友圈，相册等功能
>    后台技术：Java,tomcat,mysql,servlet,jsp
>    前端技术：html,js,css,ajax
>    通信技术：websocket,json
>
>  - networkGame
>
>    基于Fabric区块链来实现网络博弈平台



### 1. Estore技术分析

分析基于Servlet相关的项目，基本步骤为：

>1. 查找web.xml文件，寻找程序的入口
>
>若web.xml文件没有配置相关信息，则可能是将配置信息用代码的方式写好了。可以从LoginServlet开始。
>
>2. 一般Servlet服务器默认的主页为index.jsp或index.html等





#### 1.1 



### 2. Wechat技术分析

该项目是使用Servlet来实现的，通过分析可知，作者通过自定义注解和Provider类来实现不同的功能。如何将Provider类与Servlert类相绑定？作者通过利用反射机制和监听机制来实现的。



#### 2.1 项目结构分析

项目的目录结构如下所示：

![项目目录结构](pics\运行逻辑.PNG)



#### 2.2 实现业务逻辑的思路

通过MyServlet作为程序的入口，通过注解WebServlet实现在web.xml文件中实现映射。

```java
@MultipartConfig(location = "C:xxx\artifacts\\wechat_war_exploded\\upload")
@WebServlet("/wechat/*")
public class MyServlet extends HttpServlet 
```

在MyServlet类中，通过providerMap来实现对业务功能的调用。其具体过程为，通过解析Http请求，得到url,再将url与providerMap中进行匹配，来实现业务的分发。

```java
 @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        Map<String, Provider>providerMap = (Map<String, Provider>) getServletContext().getAttribute("providerMap");
        String url = req.getRequestURI();
        Set<String> keys = providerMap.keySet();
        Logger logger = Logger.getLogger(MyServlet.class);
        logger.info("[请求url:]"+url+"[匹配provider]:"+url.substring(14));
        boolean isMatch=false;
        for (String key : keys) {
            //解析注解中的path信息，匹配ActionProvider
            String path =providerMap.get(key).getPath();
            if (url.substring(14).equalsIgnoreCase(path)) {
                providerMap.get(key).doAction(req, resp);
                logger.info("provider 分发完毕");
                isMatch=true;
            }
        }
```

而providerMap从何而来呢？观察到在项目中有一个ServletContextListener，实现了任务的注册：

```java
@WebListener
public class ServletContextListener implements javax.servlet.ServletContextListener {

    private static final ConcurrentHashMap<String, Provider> providerMap = new ConcurrentHashMap<>();

    @Override
    public void contextInitialized(ServletContextEvent sce) {

        /**
         * 用来装载provider的容器
         */
        //注册服务
        providerMap.put("userProvider", new UserProvider());
        providerMap.put("chatProvider", new ChatProvider());
        providerMap.put("uploadProvider", new UploadProvider());
        providerMap.put("friendProvider", new FriendProvider());
        providerMap.put("momentProvider",new MomentProvider());
        providerMap.put("messageProvider",new MessageProvider());
        providerMap.put("remarkProvider",new RemarkProvider());
        //将controllerMap注入ServletContext
        ServletContext sc = sce.getServletContext();
        sc.setAttribute("providerMap", providerMap);
    }
```

这就是Provider能够担任Servlet角色的原因。

